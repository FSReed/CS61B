# Inheritance (CS61B Lecture 8)

[Lecture Video](https://www.youtube.com/playlist?list=PL8FaHk7qbOD7Ycy9QeJSPXVoTwAH52Rlw)

## Method Overloadding

When a method can be used for 2 or more different classes, it's ok in Java to define multiple methods with same name.

### Downsides

1. Code will be unnecessarily long.
2. Repeating yourself is asesthetically gross.
3. More code to maintain.
   - Any change made to one, must be made to another.
   - So does bug-fixing.
4. Another class added, another function needed.

## Inheritance in Java

We will use a new keyword `interface` to define an Interface.

```Java
public interface Father<Item> {
    Interfaces;
}
```

Then the inherients would implement this interface, by using keyword `implements`

```Java
public class Inherient1 implements Father<Item> {
    Implements1;
}

public class Inherient2 implements Father<Item> {
    Implements2;
}
```

Then a method which takes in a Father object can be used on both Inherients defined above.

## Overriding

If a "subclass" has a method with the exact same signature as in the "superclass", we say the **SUBCLASS** overrides the **METHOD**.

NOTE: We can add an `@Override` tag above the overrided methods. The only effect of this tag is: The code won't compile if it is not actually an overriding method.

## Interface Inheritance

- Interface: The list of all method signatures.
- Inheritance: The subclass "inherits" the interface from a superclass.
- Interface specifies what the subclass can do, but not how.
- Subclasses **MUST** overrides all of these methods!
  - Will fail to compile otherwise.

## Implementation Inheritance

In interface inheritence, subclass inherits signatures, but **NOT** implementation. How to make subclasses inherit implementations?

**Use `default` keyword to do this**

```Java
// Inside the class Father
default public void methodName() {
    Implementations;
}
```

Then this method can be straightly used in Inherients.
Note: If a subclass wants to override the default method in Father class, an `@Override` tag is necessary. Without this tag, the method won't be overriden.

### The Dangers of Implementation Inheritance

[Check the video here](https://www.youtube.com/watch?v=9KuVnIje2Ys&list=PL8FaHk7qbOD7Ycy9QeJSPXVoTwAH52Rlw&index=11)

## Inherit from another class: Using keyword extends

When we want one class to be a hyponym of an interface, we use `inplements`  
But when we want one class to be a hyponym of another class, we need to use a new keyword: `extends` like this:

```Java
public class InheritFromInherient1 extends Inherient1 {
    Implementations;
}
```

### How to override functions in subclasses?

We need another new keyword: **`super`**, like:

```Java
@Override
public void overridingMethod() {
    super.overridingMethod(); // This line means we are using the superclass's origin method.
}
```

### Calling Other Constructors

If we want to use a super constructor other than the no-argument constructor, we need to give the parameters to super. Otherwise we're calling the default constructor of super which has no arguments.

## Encapsulation

[Video link here](https://www.youtube.com/watch?v=GioVGLuW69o&list=PL8FaHk7qbOD6Mi8gDriGGeSnHi68QLuVD&index=6)

### The implementation inheritence can break the encapsulation

See the code down here:

```Java
public class Dog {
    public void bark() {
        barkMany(1);
    }

    public void barkMany(int N) {
        for (int i = 0; i < N; i++) {
            System.out.println("bark!");
        }
    }
}

public class VerboseDog extends Dog {
    @Override
    public void barkMany(int N) {
        System.out.println("As a dog, I say:");
        for (int i = 0; i < N; i++) {
            bark();
        }
    }
}
```

Everything seems to be fine, logically. Now assume `vd` is a VerboseDog instance, what will happen if we call `vd.barkMany(3)`?  
We'll get stuck into an infinite loop!

## Dynamic Method Selection and Compile-Time Type Checking

- If overridden, decide which method to call based on **run-time** type.
- Compiler allows method calls based on compile-time type of variable.

Here is the simple of the compile-time type checking. The *VengefulSLList* is a subclass of SLList, check this in [lecture video](https://www.youtube.com/watch?v=RJ_OpzLeHeQ&list=PL8FaHk7qbOD6Mi8gDriGGeSnHi68QLuVD&index=3)

![Image](./Images/Pic5_1.png)

Expressions have compile-time types.  
For example: `SLList<Integer> sl = new VengefulSLList<Integer> vsl;`. Compile-time type of tight hand side expression is VengefulSLList, and **A VengefulSLList is a SLList**, so the assighment is allowed. Therefore, is the two sides exchange, the assignment can't compile.

## Casting

Java has a special syntax for forcing the compile-time type of any expression. Put desired type in parenthesis before the expression.
